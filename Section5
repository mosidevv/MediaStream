Server-side rendering with data::
Lecture 1:
SEO is important for any web application that delivers content to its users and wants
to make the content easy to find. Generally, content on any web page will have a
better chance of getting more viewers if the content is easily readable to search
engines. When a search-engine bot accesses a web URL, it will get the SSR output.
Hence, to make the content discoverable, the content should be part of the SSR
output.

--we will use the case of making media details popular across
search engine results, to demonstrate how to inject data into an SSR view in a MERNbased
application. We will focus on implementing SSR with data injected for the
PlayMedia component that is returned at the '/media/:mediaId' path. The
general implementation steps outlined here can be used to implement SSR with data
for other views.

--We will first define a
static route configuration file and use it to update the existing SSR code in the
backend to inject the necessary media data from the database. Then, we will update
the frontend code to render this server-injected data in the view, and, finally, check if
this SSR implementation works as expected.

Lecture 2:
Adding a route configuration file::
--In order to load data for the React views when these are rendered on the server, we
will need to list the frontend routes in a route configuration file. This file may then be
used with the react-router-config module, which provides static route
configuration helpers for React Router.

******yarn add react-router-config************

--we will create a route configuration file that will list frontend React Router
routes. This configuration will be used on the server to match these routes with
incoming request URLs, to check whether data must be injected before the server
returns the rendered markup in response to this request.

Updating SSR code for the Express server::
--we will first see how to use the route configuration to load the
data that needs to be injected when the server renders React components. Then, we
will integrate isomorphic-fetch so the server is able to make the read fetch call to
retrieve the necessary data, using the same API fetching code from the frontend.
--Finally, we will inject this retrieved data into the markup generated by the server.

Using route configuration to load data::
--We will use the routes defined in the route configuration file to look for a matching
route when the server receives any request. If a match is found, we will use the
corresponding loadData method declared for this route in the configuration to
retrieve the necessary data, before it is injected into the server-rendered markup
representing the React frontend.