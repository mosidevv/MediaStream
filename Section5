Server-side rendering with data::
Lecture 1:
SEO is important for any web application that delivers content to its users and wants
to make the content easy to find. Generally, content on any web page will have a
better chance of getting more viewers if the content is easily readable to search
engines. When a search-engine bot accesses a web URL, it will get the SSR output.
Hence, to make the content discoverable, the content should be part of the SSR
output.

--we will use the case of making media details popular across
search engine results, to demonstrate how to inject data into an SSR view in a MERNbased
application. We will focus on implementing SSR with data injected for the
PlayMedia component that is returned at the '/media/:mediaId' path. The
general implementation steps outlined here can be used to implement SSR with data
for other views.

--We will first define a
static route configuration file and use it to update the existing SSR code in the
backend to inject the necessary media data from the database. Then, we will update
the frontend code to render this server-injected data in the view, and, finally, check if
this SSR implementation works as expected.

Lecture 2:
Adding a route configuration file::
--In order to load data for the React views when these are rendered on the server, we
will need to list the frontend routes in a route configuration file. This file may then be
used with the react-router-config module, which provides static route
configuration helpers for React Router.

******yarn add react-router-config************

--we will create a route configuration file that will list frontend React Router
routes. This configuration will be used on the server to match these routes with
incoming request URLs, to check whether data must be injected before the server
returns the rendered markup in response to this request.

Updating SSR code for the Express server::
--we will first see how to use the route configuration to load the
data that needs to be injected when the server renders React components. Then, we
will integrate isomorphic-fetch so the server is able to make the read fetch call to
retrieve the necessary data, using the same API fetching code from the frontend.
--Finally, we will inject this retrieved data into the markup generated by the server.

Using route configuration to load data::
--We will use the routes defined in the route configuration file to look for a matching
route when the server receives any request. If a match is found, we will use the
corresponding loadData method declared for this route in the configuration to
retrieve the necessary data, before it is injected into the server-rendered markup
representing the React frontend.

Lecture 3:
Isomorphic-fetch::
--We will ensure that any fetch method we defined for the client code can also be used
on the server by using the isomorphic-fetch Node module.

***yarn add isomorphic-fetch*********

--This isomorphic-fetch integration will make sure that the read fetch method, or
any other fetch method that we defined for the client, can now be used on the server
as well

Absolute URLs::
--One issue with using isomorphic-fetch is that it currently requires the fetch URLs
to be absolute. So, we need to update the URL used in the read fetch method, defined
in api-media.js, into an absolute URL.

--Instead of hardcoding a server address in the code, we will set a config variable in
config.js,
--This will allow us to define and use separate absolute URLs for the API routes in
development and in production.

--we will update the read method in api-media.js to make sure it uses an
absolute URL to call the read API on the server.

--This will make the read fetch call compatible with isomorphic-fetch, so it can be
used without a problem on the server side to retrieve the media data while serverrendering
the PlayMedia component with data.

Lecture 4:
Injecting data into the React app::

Applying server-injected data to client code::
--may be injected from the server if the view is being rendered server-side.
--we will access the media data
passed from the server, and add it to the PlayMedia view when the server receives a
direct request to render this component.

Passing data props to PlayMedia from MainRouter::


Rendering received data in PlayMedia::
--we will check for data passed from the server and set
the values to the state so the media details are rendered in the view when the server is
generating the corresponding markup.

--We also set the relatedMedia value to an empty array, as we do not
intend to render the related media list in the server-generated version. This
implementation will produce server-generated markup with media data injected in
the PlayMedia view when the corresponding frontend route request is received
directly on the server.

Checking the implementation of SSR with data::
--For MERN Mediastream, any of the links that render PlayMedia should now
generate markup on the server side with media details preloaded. We can verify that
the implementation for SSR with data is working properly by opening the app URL in
a browser, with JavaScript turned off. In the following section, we will look into how
to achieve this check in the Chrome browser, and what the resulting view should
show to the user and to a search engine.

Testing in Chrome::
--Testing this implementation in Chrome just requires updating the Chrome settings
and loading the application in a tab, with JavaScript blocked.

Loading a page with JavaScript enabled::
pg 553

PlayMedia view with JavaScript blocked::
--When JavaScript is blocked in the browser, the PlayMedia view should render with
only the media details populated. But the user interface is no longer interactive as
JavaScript is blocked, and only the default browser controls are operational,

--This is the markup that a search-engine bot will read for media content, and also what
a user will see when no JavaScript loads on the browser. If this implementation
for SSR with data was not added to the application, then this view would render
without the associated media details in this scenario, and hence the media
information would not be read and indexed by search engines