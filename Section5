Server-side rendering with data::
Lecture 1:
SEO is important for any web application that delivers content to its users and wants
to make the content easy to find. Generally, content on any web page will have a
better chance of getting more viewers if the content is easily readable to search
engines. When a search-engine bot accesses a web URL, it will get the SSR output.
Hence, to make the content discoverable, the content should be part of the SSR
output.

--we will use the case of making media details popular across
search engine results, to demonstrate how to inject data into an SSR view in a MERNbased
application. We will focus on implementing SSR with data injected for the
PlayMedia component that is returned at the '/media/:mediaId' path. The
general implementation steps outlined here can be used to implement SSR with data
for other views.

--We will first define a
static route configuration file and use it to update the existing SSR code in the
backend to inject the necessary media data from the database. Then, we will update
the frontend code to render this server-injected data in the view, and, finally, check if
this SSR implementation works as expected.

Lecture 2:
Adding a route configuration file::
--In order to load data for the React views when these are rendered on the server, we
will need to list the frontend routes in a route configuration file. This file may then be
used with the react-router-config module, which provides static route
configuration helpers for React Router.

******yarn add react-router-config************

--we will create a route configuration file that will list frontend React Router
routes. This configuration will be used on the server to match these routes with
incoming request URLs, to check whether data must be injected before the server
returns the rendered markup in response to this request.

Updating SSR code for the Express server::
--we will first see how to use the route configuration to load the
data that needs to be injected when the server renders React components. Then, we
will integrate isomorphic-fetch so the server is able to make the read fetch call to
retrieve the necessary data, using the same API fetching code from the frontend.
--Finally, we will inject this retrieved data into the markup generated by the server.

Using route configuration to load data::
--We will use the routes defined in the route configuration file to look for a matching
route when the server receives any request. If a match is found, we will use the
corresponding loadData method declared for this route in the configuration to
retrieve the necessary data, before it is injected into the server-rendered markup
representing the React frontend.

Lecture 3:
Isomorphic-fetch::
--We will ensure that any fetch method we defined for the client code can also be used
on the server by using the isomorphic-fetch Node module.

***yarn add isomorphic-fetch*********

--This isomorphic-fetch integration will make sure that the read fetch method, or
any other fetch method that we defined for the client, can now be used on the server
as well

Absolute URLs::
--One issue with using isomorphic-fetch is that it currently requires the fetch URLs
to be absolute. So, we need to update the URL used in the read fetch method, defined
in api-media.js, into an absolute URL.

--Instead of hardcoding a server address in the code, we will set a config variable in
config.js,
--This will allow us to define and use separate absolute URLs for the API routes in
development and in production.

--we will update the read method in api-media.js to make sure it uses an
absolute URL to call the read API on the server.

--This will make the read fetch call compatible with isomorphic-fetch, so it can be
used without a problem on the server side to retrieve the media data while serverrendering
the PlayMedia component with data.